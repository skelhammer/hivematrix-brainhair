<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brainhair - AI Assistant</title>
    <script src="https://unpkg.com/lucide@latest"></script>
</head>
<body class="u-no-scroll">
    <div class="chat">
        <div class="chat__header">
            <h1 class="chat__title">Brainhair</h1>
            <div class="chat__header-actions">
                <button class="btn" onclick="window.location.href='{{ url_for('index') }}'">
                    <span class="btn__label">
                        <i data-lucide="arrow-left" class="btn__icon"></i>
                        Back to Dashboard
                    </span>
                </button>
                <button class="btn chat__new-button" onclick="newChat()">
                    <span class="btn__label">
                        <i data-lucide="plus" class="btn__icon"></i>
                        New Chat
                    </span>
                </button>
            </div>
        </div>

        <div class="chat__messages" id="messages">
            <div class="chat__message chat__message--assistant">
                <div class="chat__message-avatar">üß†</div>
                <div class="chat__message-content">
                    <p><strong>Hello! I'm Brainhair</strong>, your AI technical support assistant.</p>
                    <p>I can help you with:</p>
                    <ul>
                        <li>Looking up tickets and client information</li>
                        <li>Searching the knowledge base</li>
                        <li>Checking device status</li>
                        <li>Running commands (with your approval)</li>
                    </ul>
                    <p>What can I help you with today?</p>
                </div>
            </div>
        </div>

        <div class="chat__typing" id="typing">
            <div class="chat__typing-dots">
                <div class="chat__typing-dot"></div>
                <div class="chat__typing-dot"></div>
                <div class="chat__typing-dot"></div>
            </div>
        </div>

        <div class="chat__input-container">
            <div class="chat__input-wrapper">
                <textarea
                    class="chat__textarea"
                    id="message-input"
                    placeholder="Send a message..."
                    rows="1"
                ></textarea>
                <button class="chat__send-button" id="send-btn" onclick="sendMessage()">
                    <i data-lucide="send" class="btn__icon"></i>
                </button>
                <button class="chat__send-button chat__send-button--stop" id="stop-btn" onclick="stopResponse()">
                    <i data-lucide="square" class="btn__icon"></i>
                </button>
            </div>
        </div>
    </div>

    <div id="approval-dialog" class="modal">
        <div class="modal__dialog">
            <div class="modal__header">
                <h2 class="modal__title">‚ö†Ô∏è Approval Required</h2>
                <button class="modal__close" onclick="denyApproval()">&times;</button>
            </div>
            <div class="modal__body">
                <div id="approval-action" class="modal__action"></div>
                <div id="approval-details" class="modal__details"></div>
            </div>
            <div class="modal__footer">
                <button class="btn btn--danger" onclick="denyApproval()">
                    <span class="btn__label">
                        <i data-lucide="x" class="btn__icon"></i>
                        Deny
                    </span>
                </button>
                <button class="btn btn--primary" onclick="approveChange()">
                    <span class="btn__label">
                        <i data-lucide="check" class="btn__icon"></i>
                        Approve
                    </span>
                </button>
            </div>
        </div>
    </div>

    <script>
        // API endpoints
        const API_CHAT = "{{ url_for('chat_message') }}";
        const API_CHAT_POLL = "{{ url_for('poll_response', response_id='RESPONSE_ID') }}".replace('RESPONSE_ID', '{response_id}');
        const API_CHAT_STOP = "{{ url_for('stop_response', response_id='RESPONSE_ID') }}".replace('RESPONSE_ID', '{response_id}');
        const API_APPROVAL_PENDING = "{{ url_for('get_pending_approvals', session_id='SESSION_ID') }}".replace('SESSION_ID', '{session_id}');
        const API_APPROVAL_RESPOND = "{{ url_for('respond_to_approval', approval_id='APPROVAL_ID') }}".replace('APPROVAL_ID', '{approval_id}');
        const API_HISTORY = "{{ url_for('list_chat_sessions') }}";
        const API_HISTORY_GET = "{{ url_for('get_chat_session', session_id='SESSION_ID') }}".replace('SESSION_ID', '{session_id}');
        const API_HISTORY_SEARCH = "{{ url_for('search_chat_history') }}";

        let sessionId = null;
        let currentDbSessionId = null;
        let pollingInterval = null;
        let approvalPollingInterval = null;
        let currentResponseId = null;
        let currentOffset = 0;
        let currentApprovalId = null;
        let lastScrollTime = 0;
        let currentStreamingMessage = null;
        let textBuffer = '';  // Buffer for typewriter effect
        let typewriterInterval = null;  // Interval for character-by-character display
        let displayedLength = 0;  // How many characters have been displayed

        // Auto-resize textarea
        const textarea = document.getElementById('message-input');
        textarea.addEventListener('input', function() {
            this.style.height = 'auto';
            this.style.height = Math.min(this.scrollHeight, 200) + 'px';
        });

        // Send on Enter (but not Shift+Enter)
        textarea.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });

        async function sendMessage() {
            const input = document.getElementById('message-input');
            const message = input.value.trim();

            if (!message) return;

            // Clear input
            input.value = '';
            input.style.height = 'auto';

            // Add user message to UI
            addMessage('user', message);

            // Reset streaming state for new response
            currentStreamingMessage = null;
            textBuffer = '';
            displayedLength = 0;
            stopTypewriter(true);

            // Show typing indicator and stop button
            showTyping();
            showStopButton();

            try {
                // Send message to backend
                const response = await fetch(API_CHAT, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        message: message,
                        session_id: sessionId,
                        db_session_id: currentDbSessionId
                    })
                });

                const data = await response.json();

                if (data.error) {
                    hideTyping();
                    hideStopButton();
                    addMessage('assistant', `‚ùå Error: ${data.error}`);
                    return;
                }

                // Start polling for response
                sessionId = data.session_id;
                currentResponseId = data.response_id;
                currentOffset = 0;
                startPolling();

            } catch (error) {
                hideTyping();
                hideStopButton();
                addMessage('assistant', `‚ùå Error: ${error.message}`);
            }
        }

        function startPolling() {
            if (pollingInterval) {
                clearInterval(pollingInterval);
            }

            const messagesDiv = document.getElementById('messages');

            pollingInterval = setInterval(async () => {
                try {
                    const url = API_CHAT_POLL.replace('{response_id}', currentResponseId) + `?offset=${currentOffset}`;
                    const response = await fetch(url);
                    const data = await response.json();

                    if (data.chunks && data.chunks.length > 0) {
                        // Process new chunks
                        for (const chunk of data.chunks) {
                            console.log('Received chunk:', chunk);
                            if (chunk.type === 'chunk') {
                                appendToLastMessage(chunk.content);
                            } else if (chunk.type === 'error') {
                                appendToLastMessage(`\n\n‚ùå ${chunk.content}`);
                            } else if (chunk.type === 'thinking') {
                                // Tool call indicator
                                appendToLastMessage(`\n\n‚öôÔ∏è ${chunk.action}\n\n`);
                            } else if (chunk.type === 'approval_request') {
                                // Show approval dialog
                                console.log('Approval request received:', chunk);
                                showApprovalDialogFromChunk(chunk);
                            }
                        }
                        currentOffset = data.offset;
                    }

                    if (data.done) {
                        clearInterval(pollingInterval);
                        hideTyping();
                        hideStopButton();

                        // Let typewriter finish naturally, then keep formatting as-is
                        const finishTyping = setInterval(() => {
                            if (displayedLength >= textBuffer.length) {
                                clearInterval(finishTyping);
                                stopTypewriter();

                                // Keep the message as-is with preserved whitespace
                                // Apply CSS to preserve whitespace formatting
                                if (currentStreamingMessage) {
                                    currentStreamingMessage.style.whiteSpace = 'pre-wrap';
                                    currentStreamingMessage = null;
                                    textBuffer = '';
                                    displayedLength = 0;
                                }

                                // Final scroll to bottom
                                messagesDiv.scrollTop = messagesDiv.scrollHeight;
                            }
                        }, 50);

                        if (data.error) {
                            addMessage('assistant', `‚ùå Error: ${data.error}`);
                        }
                    }
                } catch (error) {
                    clearInterval(pollingInterval);
                    hideTyping();
                    hideStopButton();
                    stopTypewriter(true); // Immediate stop for errors
                    currentStreamingMessage = null;
                    textBuffer = '';
                    displayedLength = 0;
                    addMessage('assistant', `‚ùå Error: ${error.message}`);
                }
            }, 300); // Poll every 300ms
        }

        function addMessage(role, content) {
            const messagesDiv = document.getElementById('messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `chat__message chat__message--${role}`;

            const avatar = document.createElement('div');
            avatar.className = 'chat__message-avatar';
            avatar.textContent = role === 'user' ? 'üë§' : 'üß†';

            const contentDiv = document.createElement('div');
            contentDiv.className = 'chat__message-content';
            contentDiv.innerHTML = formatMessage(content);

            messageDiv.appendChild(avatar);
            messageDiv.appendChild(contentDiv);
            messagesDiv.appendChild(messageDiv);

            // Scroll to bottom
            messagesDiv.scrollTop = messagesDiv.scrollHeight;

            return contentDiv;
        }

        function startTypewriter() {
            if (typewriterInterval) return; // Already running

            const messagesDiv = document.getElementById('messages');

            typewriterInterval = setInterval(() => {
                if (displayedLength < textBuffer.length) {
                    // Display next character
                    displayedLength++;
                    currentStreamingMessage.textContent = textBuffer.substring(0, displayedLength);

                    // Throttled scroll
                    const now = Date.now();
                    if (now - lastScrollTime > 100) {
                        messagesDiv.scrollTop = messagesDiv.scrollHeight;
                        lastScrollTime = now;
                    }
                }
            }, 8); // 8ms per character = smooth 125 chars/second
        }

        function stopTypewriter(immediate = false) {
            if (typewriterInterval) {
                clearInterval(typewriterInterval);
                typewriterInterval = null;
            }

            if (immediate) {
                // Instant display for errors
                if (currentStreamingMessage && displayedLength < textBuffer.length) {
                    currentStreamingMessage.textContent = textBuffer;
                    displayedLength = textBuffer.length;
                }
            }
            // Otherwise let the typewriter naturally finish in the background
        }

        function appendToLastMessage(content) {
            const messagesDiv = document.getElementById('messages');

            // Create streaming message if it doesn't exist
            if (!currentStreamingMessage) {
                const messages = messagesDiv.querySelectorAll('.chat__message');
                const lastMessage = messages.length > 0 ? messages[messages.length - 1] : null;

                // If last message is from user or not an assistant message, create new one
                if (!lastMessage || !lastMessage.classList.contains('chat__message--assistant')) {
                    const messageDiv = document.createElement('div');
                    messageDiv.className = 'chat__message chat__message--assistant';

                    const avatar = document.createElement('div');
                    avatar.className = 'chat__message-avatar';
                    avatar.textContent = 'üß†';

                    const contentDiv = document.createElement('div');
                    contentDiv.className = 'chat__message-content';

                    // Create a text node container for streaming
                    const streamingContainer = document.createElement('div');
                    streamingContainer.className = 'chat__streaming-text';
                    contentDiv.appendChild(streamingContainer);

                    messageDiv.appendChild(avatar);
                    messageDiv.appendChild(contentDiv);
                    messagesDiv.appendChild(messageDiv);

                    currentStreamingMessage = streamingContainer;
                } else {
                    // Use existing message
                    const contentDiv = lastMessage.querySelector('.chat__message-content');
                    let streamingContainer = contentDiv.querySelector('.chat__streaming-text');

                    if (!streamingContainer) {
                        streamingContainer = document.createElement('div');
                        streamingContainer.className = 'chat__streaming-text';
                        contentDiv.appendChild(streamingContainer);
                    }

                    currentStreamingMessage = streamingContainer;
                }

                // Start typewriter effect when first chunk arrives
                startTypewriter();
            }

            // Add content to buffer instead of directly to DOM
            textBuffer += content;
        }

        function formatMessage(text) {
            // Preserve code blocks first (replace with placeholders)
            const codeBlocks = [];
            text = text.replace(/```([\s\S]*?)```/g, (match, code) => {
                codeBlocks.push(`<pre><code>${code}</code></pre>`);
                return `__CODEBLOCK_${codeBlocks.length - 1}__`;
            });

            // Markdown-like formatting
            text = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            text = text.replace(/\*(.*?)\*/g, '<em>$1</em>');
            text = text.replace(/`(.*?)`/g, '<code>$1</code>');

            // Convert double newlines to paragraph breaks
            text = text.replace(/\n\n/g, '</p><p>');

            // Convert single newlines to <br>
            text = text.replace(/\n/g, '<br>');

            // Wrap in paragraph tags if not empty
            if (text.trim()) {
                text = '<p>' + text + '</p>';
            }

            // Restore code blocks
            codeBlocks.forEach((block, i) => {
                text = text.replace(`__CODEBLOCK_${i}__`, block);
            });

            return text;
        }

        function showTyping() {
            const typing = document.getElementById('typing');
            typing.classList.add('chat__typing--visible');
        }

        function hideTyping() {
            const typing = document.getElementById('typing');
            typing.classList.remove('chat__typing--visible');
        }

        function showStopButton() {
            document.getElementById('send-btn').classList.add('is-hidden');
            document.getElementById('stop-btn').classList.add('active');
        }

        function hideStopButton() {
            document.getElementById('stop-btn').classList.remove('active');
            document.getElementById('send-btn').classList.remove('is-hidden');
        }

        async function stopResponse() {
            if (!currentResponseId) {
                console.warn('No active response to stop');
                return;
            }

            try {
                const url = API_CHAT_STOP.replace('{response_id}', currentResponseId);
                const response = await fetch(url, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'}
                });

                const data = await response.json();

                if (data.success) {
                    // Stop polling
                    if (pollingInterval) {
                        clearInterval(pollingInterval);
                        pollingInterval = null;
                    }
                    hideTyping();
                    hideStopButton();
                    console.log('Response stopped successfully');
                } else {
                    console.error('Failed to stop response:', data.message);
                }
            } catch (error) {
                console.error('Error stopping response:', error);
            }
        }

        // ==================== Approval Functions ====================

        function showApprovalDialogFromChunk(chunk) {
            console.log('showApprovalDialogFromChunk called with:', chunk);
            // Chunk has: approval_id, action, details
            currentApprovalId = chunk.approval_id;

            // Set action text
            document.getElementById('approval-action').textContent = chunk.action;

            // Set details
            const detailsDiv = document.getElementById('approval-details');
            detailsDiv.innerHTML = '';
            for (const [key, value] of Object.entries(chunk.details || {})) {
                const detail = document.createElement('div');
                detail.className = 'modal__detail';
                detail.innerHTML = `<strong>${key}:</strong> ${value}`;
                detailsDiv.appendChild(detail);
            }

            // Show dialog
            console.log('Showing approval dialog');
            const dialog = document.getElementById('approval-dialog');
            dialog.classList.add('active');
            console.log('Dialog active class added, element:', dialog);
        }

        async function approveChange() {
            if (!currentApprovalId) return;

            try {
                const url = API_APPROVAL_RESPOND.replace('{approval_id}', currentApprovalId);
                const response = await fetch(url, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ approved: true })
                });

                if (response.ok) {
                    hideApprovalDialog();
                }
            } catch (error) {
                console.error('Error approving change:', error);
            }
        }

        async function denyApproval() {
            if (!currentApprovalId) {
                // Just close if no approval pending
                hideApprovalDialog();
                return;
            }

            try {
                const url = API_APPROVAL_RESPOND.replace('{approval_id}', currentApprovalId);
                const response = await fetch(url, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ approved: false })
                });

                if (response.ok) {
                    hideApprovalDialog();
                }
            } catch (error) {
                console.error('Error denying change:', error);
            }
        }

        function hideApprovalDialog() {
            document.getElementById('approval-dialog').classList.remove('active');
            currentApprovalId = null;
        }

        function newChat() {
            sessionId = null;
            currentDbSessionId = null;
            const messagesDiv = document.getElementById('messages');
            messagesDiv.innerHTML = `
                <div class="chat__message chat__message--assistant">
                    <div class="chat__message-avatar">üß†</div>
                    <div class="chat__message-content">
                        <p><strong>Hello! I'm Brainhair</strong>, your AI technical support assistant.</p>
                        <p>I can help you with:</p>
                        <ul>
                            <li>Looking up tickets and client information</li>
                            <li>Searching the knowledge base</li>
                            <li>Checking device status</li>
                            <li>Running commands (with your approval)</li>
                        </ul>
                        <p>What can I help you with today?</p>
                    </div>
                </div>
            `;
        }

        // Check for session parameter in URL and load session if present
        async function loadSessionFromUrl() {
            const urlParams = new URLSearchParams(window.location.search);
            const sessionParam = urlParams.get('session');

            if (sessionParam) {
                try {
                    const url = API_HISTORY_GET.replace('{session_id}', sessionParam);
                    const response = await fetch(url);
                    const data = await response.json();

                    if (data.error) {
                        console.error('Error loading session:', data.error);
                        return;
                    }

                    // Clear current chat
                    const messagesDiv = document.getElementById('messages');
                    messagesDiv.innerHTML = '';

                    // Load messages
                    if (data.messages) {
                        data.messages.forEach(msg => {
                            addMessage(msg.role, msg.content);
                        });
                    }

                    // Set session IDs
                    currentDbSessionId = sessionParam;
                    sessionId = null; // Will be created on next message

                    // Clear URL parameter
                    window.history.replaceState({}, document.title, window.location.pathname);

                } catch (error) {
                    console.error('Error resuming session:', error.message);
                }
            }
        }

        // Initialize Lucide icons and load session if URL parameter present
        window.addEventListener('DOMContentLoaded', () => {
            lucide.createIcons();
            loadSessionFromUrl();
        });
    </script>
    <div class="version-footer">
        <span class="version-footer__text">{{ app_service_name }} v{{ app_version }}</span>
    </div>
</body>
</html>
